# Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив, заданный случайными числами на
# промежутке [-100; 100). Выведите на экран исходный и отсортированный массивы. Сортировка должна быть реализована в
# виде функции. По возможности доработайте алгоритм (сделайте его умнее).

from random import randint


def bubble_sort(arr, reverse=False):  # С помощью параметра reverse можно задавать порядок сортировки: по убыванию
                                      # или по возрастанию.
    def counter(x):
        if x == 0:
            return len(arr)
        else:
            return n

    n = 1
    count = 0
    if reverse:
        while n < len(arr):
            for i in range(len(arr) - n):
                if arr[i] < arr[i+1]:
                    arr[i], arr[i+1] = arr[i+1], arr[i]
                    count += 1  # Считаем количество замен, потом вызываем функцию counter, если количество перестановок
            n = counter(count)  # равно нулю, значит, массив отсортирован и можно выходить из цикла.
            n += 1
    else:
        while n < len(arr):
            for i in range(len(arr) - n):
                if arr[i] > arr[i + 1]:
                    arr[i], arr[i + 1] = arr[i + 1], arr[i]
                    count += 1
            n = counter(count)
            n += 1

    return arr


example_arr = [randint(-100, 100) for _ in range(20)]
# example_arr = [5, 4, 3, 2, 1]
print(f'Исходный массив: {example_arr},\n'
      f'Отсортированный массив: {bubble_sort(example_arr, reverse=True)}.')

# Поскольку в зависимости от параметра reverse выполняется один и тот же код, различающийся только в знаке сравнения,
# то я долго думал, как можно избавиться от дублирующего кода, но в голову ничего дельного не пришло к сожалению.
# Буду рад, если направите в нужное русло.
